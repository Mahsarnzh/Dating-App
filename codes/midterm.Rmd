---
title: "Midterm"
author: "Mahsa Raeisinezhad"
date: "2023-06-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
library(tidyverse)
```

```{r}
steam <- readr::read_csv('midterm_steam.csv', col_names = TRUE)
```

```{r}
glimpse(steam)
```





## Which variable has the most missing values?
game_metascore with 5477 number of missing values has the highest number of missing values

```{r}
missing_counts <- sapply(steam, function(x) sum(is.na(x)))
print(missing_counts)
```
## Which variable has the most unique values?
game_name with 6765 unique values has the most unique number of values

```{r}
unique_values <- sapply(steam, function(x) length(unique(x)))

# Display the number of unique values per column
print(unique_values)
```

```{r}
steam %>% 
  summarise(number_unique = n_distinct(game_name))
```
## How many publishers are in the data set?
262 game_publisher are presented in this dataset

```{r}
steam %>% 
  summarise(number_unique = n_distinct(game_publisher))
```

```{r}
steam %>% keep(is.factor) %>% summary()
```

```{r}
steam %>% pull(game_name) %>% class()
```

```{r}
steam %>% count(number_owners)
```

[1] "game_name"
[1] "game_developer"
[1] "game_publisher"
[1] "number_owners"


```{r}

for (var_name in names(steam)) {
  if (is.character(steam[[var_name]])) {
    plot_data <- steam %>%
      ggplot(mapping = aes(y = .data[[var_name]])) +
      geom_bar() +
      geom_text(stat = 'count',
                mapping = aes(label = after_stat(count)),
                color = 'red', nudge_x = 20, size = 2.5) +
      theme_bw()

    suppressWarnings(print(plot_data))
  }
}
```


## Of the publishers with at least 50 games, which publisher has the highest MEAN average playtime? Are you confident it is the highest?

As it is illustrated in the figure below, Ubisoft has the highest average_playtime amongst the publishers with at least 50 games 

```{r}
publisher_counts <- table(steam$game_publisher)

publishers_at_least_50 <- names(publisher_counts[publisher_counts >= 50])

# Filter the dataset to include only the publishers with at least 50 games
filtered_dataset <- steam[steam$game_publisher %in% publishers_at_least_50, ]

num_publishers_at_least_50 <- length(publishers_at_least_50)
print(num_publishers_at_least_50)
```

# How many publishers published at least 50 games in this data set?
28 publishers has published at least 50 games in the dataset 
 
 
```{r}
publisher_counts <- table(filtered_dataset$game_publisher)
print(publisher_counts)

```


```{r}
mean_playtime <- filtered_dataset %>%
  group_by(game_publisher) %>%
  summarize(mean_average_playtime = mean(average_playtime, na.rm = TRUE))

# Find the publisher with the highest mean average playtime
max_mean_playtime <- mean_playtime %>%
  filter(mean_average_playtime == max(mean_average_playtime))

# Print the publisher with the highest mean average playtime
print(max_mean_playtime)
```

## Do the publishers with at least 50 games in the data favor releasing games on one day of the week over the others?

Yes, for example Dagestan Technology prefers the 6th day of the week based on the plots below, however, Square Enix prefers the 3rd day of the week
```{r}
filtered_dataset %>%
  ggplot(mapping = aes(x = release_dayofweek)) +
  geom_histogram(bins =14) +
  facet_wrap(~ game_publisher, ncol = 3) +
  theme_bw()

```




```{r}
filtered_dataset %>% 
  mutate(game_publisher = fct_reorder(game_publisher, average_playtime, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = game_publisher, x = average_playtime)) +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 2),
               color = 'red', linewidth = 1.0, size = 0.5) +
  theme_bw()
```



```{r}
filtered_dataset %>%
  ggplot(mapping = aes(y = game_publisher, x = average_playtime)) +
  geom_col() +
  theme_bw() 
```




```{r}
steam %>% 
  ggplot(mapping = aes(y = game_publisher)) +
  geom_bar() +
  theme_bw()
```


Since the plots above, specifically "game_name", "game_developer", and "game_publisher"are not understandable, we can drop negligible proportions of the data, using `fct_lump_prop()`




```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.006, other_level = '(OTHER)')) %>% 
  select(game_publisher) %>% 
  summary()
```


```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.006, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  ggplot(mapping = aes(y = game_publisher)) +
  geom_bar() +
  geom_text(stat = 'count',
            mapping = aes(label = after_stat(count)),
            color = 'red', hjust = -0.1, size = 2) +
  theme_bw()
```


```{r}
steam %>% 
  mutate(game_name = fct_lump_prop(game_name, prop = 0.00015, other_level = '(OTHER)')) %>% 
  mutate(game_name = fct_infreq(game_name)) %>% 
  mutate(game_name = fct_rev(game_name)) %>% 
  ggplot(mapping = aes(y = game_name)) +
  geom_bar() +
  geom_text(stat = 'count',
            mapping = aes(label = after_stat(count)),
            color = 'red', hjust = 0.0, size = 3) +
  theme_bw()
```



```{r}
steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.003, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  ggplot(mapping = aes(y = game_developer)) +
  geom_bar() +
  geom_text(stat = 'count',
            mapping = aes(label = after_stat(count)),
            color = 'red', nudge_x = 200, size = 3) +
  theme_bw()
```



[1] "game_name"
[1] "game_developer"
[1] "game_publisher"
[1] "number_owners"
## Which months have the most games released?
Month 10 with the count 685 has the highest count of releases and then month 9 with the count 669, have the most games released.

```{r}
steam %>% 
  ggplot(mapping = aes(x = release_month)) +
  geom_histogram(bins = 24) +
  geom_text(stat = 'count',
            mapping = aes(label = after_stat(count)),
            color = 'red', nudge_y = 20, size = 4) +
  theme_bw()
```

# Are the games in this data set released more frequently on one day of the week?
As we can observe from the histogram below, the maximum number of released games are more frequently on the 6th day of the week with the count of 1641

```{r}
steam %>% 
  ggplot(mapping = aes(x = release_dayofweek)) +
  geom_histogram(bins = 20) +
  geom_text(stat = 'count',
            mapping = aes(label = after_stat(count)),
            color = 'red', nudge_y = 50, size = 4) +
  theme_bw()
```
## Does the most frequent release day of the week vary across the number of owners of the game?
As we can see in the plots below, the most frequent release day of the week varies across the number of owners of the game


```{r}
steam %>% 
  ggplot(mapping = aes(x = release_dayofweek, fill = number_owners)) +
  geom_histogram(bins = 11) +
  geom_rug(linewidth = 1.2) +
  facet_wrap( ~number_owners, scales = 'free' ) +
  theme_bw()
```




```{r}
steam %>% 
  ggplot(mapping = aes(y = number_owners)) +
  geom_bar() +
  geom_text(stat = 'count',
          mapping = aes(label = after_stat(count)),
          color = 'red', nudge_x = 200, size = 3) +
  theme_bw()
```


```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  ggplot(mapping = aes(y = game_publisher)) +
  geom_bar() +
  geom_text(stat = 'count',
          mapping = aes(label = after_stat(count)),
          color = 'red', nudge_x = 200, size = 3) +
  theme_bw()
```

```{r}

steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.003, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  count(game_metascore, game_developer) %>% 
  
  ggplot(mapping = aes(x = game_metascore, y = game_developer)) +
  geom_tile(mapping = aes(fill = n),
            color = 'black') +
  geom_text(mapping = aes(label = n),
          color = 'red', size= 2) +

  theme_bw()
```


```{r}

steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.006, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  count(game_metascore, game_publisher) %>% 
  
  ggplot(mapping = aes(x = game_metascore, y = game_publisher)) +
  geom_tile(mapping = aes(fill = n),
            color = 'black') +
  geom_text(mapping = aes(label = n),
          color = 'red', size= 2) +

  theme_bw()
```



[1] "game_name"
[1] "game_developer"
[1] "game_publisher"
[1] "number_owners"


```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.006, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  mutate(game_name = fct_lump_prop(game_name, prop = 0.00015, other_level = '(OTHER)')) %>% 
  mutate(game_name = fct_infreq(game_name)) %>% 
  mutate(game_name = fct_rev(game_name)) %>% 
  count(game_name, game_publisher) %>% 
  
  ggplot(mapping = aes(x = game_name, y = game_publisher)) +
  geom_tile(mapping = aes(fill = n),
            color = 'black') +
  geom_text(mapping = aes(label = n),
          color = 'red', size= 2) +

  theme_bw()
```



```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  count(number_owners, game_publisher) %>% 
  
  ggplot(mapping = aes(x = number_owners, y = game_publisher)) +
  geom_tile(mapping = aes(fill = n),
            color = 'black') +
  geom_text(mapping = aes(label = n),
          color = 'red', size= 2) +

  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))


```





## MARGINAL distributions of continuous variables
```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value, y = after_stat(density))) +
  geom_histogram(bins =30, linewidth = 1.) +
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()
```


```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(linewidth = 0.2) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```


## CONDITIONAL distributions of continuous variables GIVEN categorical variables


# Does the distribution of game price depend on the number of owners?
Each boxplot shows the distribution of game prices for a specific number of owners. As we can see the distribution varies. Also based on the ecdf plots the shape of the distributions are different as well.

```{r}
steam %>% 
  mutate(number_owners = fct_reorder(number_owners,game_price, .fun = 'median')) %>% 
  ggplot(mapping = aes(x = game_price, y = number_owners)) +
  geom_boxplot(mapping = aes(fill=number_owners)) +
  stat_summary(fun = 'mean', geom = 'point',
               color = 'red', size = 1.5) +
  theme_bw()
```



```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = number_owners),
            linewidth = 0.2) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```


# Does the proportion of games with median playtime equaling zero vary across the number of owners of the game?


```{r}
steam$is_zero_median_playtime <- ifelse(steam$median_playtime == 0,TRUE ,  FALSE)
```
  
```{r}
steam %>%  glimpse()
```
Yes, as it is illustrated in the plot, owners with the value 500,000-1,000,000 and 1,000,000-2,000,000 have the highest count in median_playtime ==0 and owners and as the number_owners increases, the median_playtime decreases

```{r}
steam %>%
  ggplot(mapping = aes(y = number_owners, fill = is_zero_median_playtime)) +
  geom_bar() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
  theme_bw()
```
```{r}
steam %>% 
  ggplot(mapping = aes(y = number_owners)) +
  geom_bar(mapping = aes(fill = is_zero_median_playtime),
           position = 'dodge') +
  theme_bw()
```
```{r}
steam %>% 
  ggplot(mapping = aes(y = number_owners)) +
  geom_bar(mapping = aes(fill = as.factor(is_zero_median_playtime))) +
  ggthemes::scale_fill_colorblind('is_zero_median_playtime') +
  theme_bw()
```


```{r}
steam %>% 
  ggplot(mapping = aes(y = number_owners)) +
  geom_bar(mapping = aes(fill = is_zero_median_playtime),
           position = 'fill') +
  labs(x = 'proportion within group') +
  theme_bw()

```

Yes, as it is illustrated in the plot, owners with the value 500,000-1,000,000 and 1,000,000-20,000,000 have the lowest proportion in median_playtime ==0 

```{r}
steam %>% 
  ggplot(mapping = aes(y = number_owners, fill = is_zero_median_playtime)) +
  geom_bar() +
  theme_bw() 
```


# Does the distribution of game price vary across number of owners AND if the median play time is greater than zero?

The boxplot and violin plot below depict the distribution of game price across different categories of the number of owners. The x-axis represents the game price, while the y-axis represents the number of owners. Each boxplot provides information about the central tendency (median), spread (interquartile range), and potential outliers of the game price within each category of the number of owners. The plots reveal variations in the distribution of game price among the different categories of owners. For instance, the category 10,000,000-20,000,000 exhibits a distribution that resembles a normal or Gaussian distribution based on the violin plot, indicating a relatively balanced spread of game prices within this owner category. Additionally, the category 500,000-1,000,000 shows a higher median game price compared to other categories, suggesting a potentially higher price range for games in this owner category.



```{r}
filtered_data <- steam[steam$median_playtime > 0, ]
```


```{r}
filtered_data %>% 
  ggplot(mapping = aes(x = game_price, y = number_owners)) +
  geom_boxplot(mapping = aes(fill=number_owners)) +
  theme_bw()
```
```{r}
filtered_data %>% 
  ggplot(mapping = aes(x = game_price, y = number_owners)) +
  geom_violin(mapping = aes(fill=number_owners)) +
  theme_bw()
```

```{r}
steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.003, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = game_developer),
            linewidth = 0.2) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```
  
```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = game_publisher),
            linewidth = 0.2) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```

  
```{r}
steam %>% 
  mutate(game_name = fct_lump_prop(game_name, prop = 0.00015, other_level = '(OTHER)')) %>% 
  mutate(game_name = fct_infreq(game_name)) %>% 
  mutate(game_name = fct_rev(game_name)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = game_name),
            linewidth = 0.2) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```


  

```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = number_owners, y = after_stat(x)),
            linewidth = 0.2) +
  facet_wrap(~name, scales = 'free_x') +
  scale_fill_viridis_c()+
  theme_bw()
```


```{r}
steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.003, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value, y = after_stat(density), color = game_developer)) +
  geom_histogram(bins =30, linewidth = 1.) +
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()
```






```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value, y = after_stat(density), color = game_publisher)) +
  geom_histogram(bins =30, linewidth = 1.) +
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()
```

```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value, y = after_stat(density), color = number_owners)) +
  geom_histogram(bins = 50, linewidth = 1.5) +
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()
```


```{r}
steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.003, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = game_developer, y = value)) +
  geom_boxplot(mapping = aes(fill = game_developer,
                             color = game_developer),
               alpha = 0.3, linewidth = 1) +
  stat_summary(fun.data = 'mean_se',
               fun.args = list(mult = 0.1),
               color = 'red', size = 0.1) +
  facet_wrap(~name, scales = 'free_y') +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

```



```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = game_publisher, y = value)) +
  geom_boxplot(mapping = aes(fill = game_publisher,
                             color = game_publisher),
               alpha = 0.3, linewidth = 1) +
  stat_summary(fun.data = 'mean_se',
               fun.args = list(mult = 0.1),
               color = 'red', size = 0.1) +
  facet_wrap(~name, scales = 'free_y') +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

```

```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = number_owners, y = value)) +
  geom_boxplot(mapping = aes(fill = number_owners,
                             color = number_owners),
               alpha = 0.3, linewidth = 1) +
  stat_summary(fun.data = 'mean_se',
               fun.args = list(mult = 0.1),
               color = 'red', size = 0.1) +
  facet_wrap(~name, scales = 'free_y') +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

```


## Please open the plot to see the full figure


```{r}
steam %>% 
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.008, other_level = '(OTHER)')) %>% 
  mutate(game_developer = fct_infreq(game_developer)) %>% 
  mutate(game_developer = fct_rev(game_developer)) %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = game_developer, y = value, size= 10)) +
  geom_hex(bins= 10,
           mapping = aes(fill = after_stat(ncount)))+  
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()+ 
  theme(axis.text.x = element_text(angle = 90))
```


```{r}
steam %>% 
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.01, other_level = '(OTHER)')) %>% 
  mutate(game_publisher = fct_infreq(game_publisher)) %>% 
  mutate(game_publisher = fct_rev(game_publisher)) %>%   
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = game_publisher, y = value, size= 10)) +
  geom_hex(bins= 10,
           mapping = aes(fill = after_stat(ncount)))+  
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()+ 
  theme(axis.text.x = element_text(angle = 90))
```
  
```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = number_owners, y = value, size= 10)) +
  geom_hex(bins= 10,
           mapping = aes(fill = after_stat(ncount)))+  
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()+ 
  theme(axis.text.x = element_text(angle = 90))
```




```{r}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = number_owners, y = value, size= 10)) +
  geom_hex(bins= 10,
           mapping = aes(fill = after_stat(ncount)))+  
  facet_wrap(~name, scales = 'free') +
  scale_fill_viridis_c()+
  theme_bw()
```


```{r}
library(GGally)

```






```{r}
for (var_name in names(steam)) {
  if (is.character(steam[[var_name]])) {
    result <- steam %>% 
      summarise(number_unique = n_distinct(!!sym(var_name)))
    print(var_name)
    print(result)
  }
}
```
[1] "game_name"
[1] "game_developer"
[1] "game_publisher"
[1] "number_owners"

As we can see number_owners have 12 unique values therefore it can be used as the best categorical variable to visaulize the distribution and relationship wrt other variables.

```{r, error=TRUE}
install.packages("ggplot2")

```



```{r}
for (var_name in names(steam)) {
  if (is.numeric(steam[[var_name]])) {
    result <- steam %>% 
      summarise(number_unique = n_distinct(!!sym(var_name)))
    print(var_name)
    print(result)
  }
}
```




We can observe that based on the first density plot, as the value of game_metascore increases, the number of owners increases as well.
However, as the game_price increases 




## Relationship between Continuous Vraiables




 
  
  

```{r}
steam %>% 
  ggplot(mapping = aes(x = game_metascore, y = game_price)) +
  geom_hex(bins = 30) +
  facet_wrap(~number_owners) +
  scale_fill_viridis_c() +
  theme_bw()
```


```{r}
steam %>% 
  ggplot(mapping = aes(x = median_playtime, y = game_price)) +
  geom_hex(bins = 30) +
  facet_wrap(~number_owners) +
  scale_fill_viridis_c() +
  theme_bw()
```

```{r}
steam %>% 
  ggplot(mapping = aes(x = free, y = game_price)) +
  geom_hex(bins = 30) +
  facet_wrap(~number_owners) +
  scale_fill_viridis_c() +
  theme_bw()
```




```{r}
steam %>% 
  ggplot(mapping = aes(x = release_year, y = game_price)) +
  geom_hex(bins = 30) +
  facet_wrap(~number_owners) +
  scale_fill_viridis_c() +
  theme_bw()
```


```{r, error =TRUE}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  print(pivot_longer)
```



```{r, error=TRUE}
steam %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "game_name", "game_developer", "game_publisher", "number_owners")) %>% 
  ggplot(mapping = aes(x = value, y = name)) +
  geom_hex(bins = 11) +
  facet_wrap(~number_owners) +
  scale_fill_viridis_c() +
  theme_bw()
```

## CONDITIONAL relationships between continuous variables GIVEN categorical variables
```{r, error=TRUE}
library(corrr)

```


```{r, error=TRUE}
steam %>% 
  keep(is.numeric) %>% 
  bind_cols(steam %>% select(number_owners)) %>% 
  group_by(number_owners) %>% 
  group_modify( ~stretch( correlate(., diagonal = 1, quiet = TRUE) ) ) %>% 
  ungroup() %>% 
  ggplot(mapping = aes(x = x, y = y)) +
  geom_tile(mapping = aes(fill = r),
            color = 'white') +
  coord_equal() +
  facet_wrap(~number_owners) +
  scale_fill_gradient2(low = 'red', mid = 'white', high = 'blue',
                       midpoint = 0,
                       limits = c(-1, 1)) +
  labs(x='', y='') +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

```
```{r, error=TRUE}
steam %>%
  mutate(game_developer = fct_lump_prop(game_developer, prop = 0.005, other_level = '(OTHER)')) %>%
  mutate(game_developer = fct_infreq(game_developer)) %>%
  mutate(game_developer = fct_rev(game_developer)) %>%
  select(game_developer, where(is.numeric)) %>%
  group_by(game_developer) %>%
  group_modify(~stretch(correlate(., diagonal = 1, quiet = TRUE))) %>%
  ungroup() %>%
  ggplot(mapping = aes(x = x, y = y)) +
  geom_tile(mapping = aes(fill = r), color = 'white') +
  coord_equal() +
  facet_wrap(~game_developer) +
  scale_fill_gradient2(low = 'red', mid = 'white', high = 'blue',
                       midpoint = 0,
                       limits = c(-1, 1)) +
  labs(x = '', y = '') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))

```
```{r, error=TRUE}
steam %>%
  mutate(game_publisher = fct_lump_prop(game_publisher, prop = 0.015, other_level = '(OTHER)')) %>%
  mutate(game_publisher = fct_infreq(game_publisher)) %>%
  mutate(game_publisher = fct_rev(game_publisher)) %>%
  select(game_publisher, where(is.numeric)) %>%
  group_by(game_publisher) %>%
  group_modify(~stretch(correlate(., diagonal = 1, quiet = TRUE))) %>%
  ungroup() %>%
  ggplot(mapping = aes(x = x, y = y)) +
  geom_tile(mapping = aes(fill = r), color = 'white') +
  coord_equal() +
  facet_wrap(~game_publisher) +
  scale_fill_gradient2(low = 'red', mid = 'white', high = 'blue',
                       midpoint = 0,
                       limits = c(-1, 1)) +
  labs(x = '', y = '') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))

```




```{r, error=TRUE}
steam %>%
  mutate(game_name = fct_lump_prop(game_name, prop = 0.00015, other_level = '(OTHER)')) %>%
  mutate(game_name = fct_infreq(game_name)) %>%
  mutate(game_name = fct_rev(game_name)) %>%
  select(game_name, where(is.numeric)) %>%
  group_by(game_name) %>%
  group_modify(~stretch(correlate(., diagonal = 1, quiet = TRUE))) %>%
  ungroup() %>%
  ggplot(mapping = aes(x = x, y = y)) +
  geom_tile(mapping = aes(fill = r), color = 'white') +
  coord_equal() +
  facet_wrap(~game_name) +
  scale_fill_gradient2(low = 'red', mid = 'white', high = 'blue',
                       midpoint = 0,
                       limits = c(-1, 1)) +
  labs(x = '', y = '') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))

```

## VEHICLE DATASET

```{r, error=TRUE}
vehicle <- readr::read_csv('midterm_vehicle.csv', col_names = TRUE)
```


```{r, error =TRUE}
library(devtools)

```


```{r, error =TRUE}
# install.packages('devtools')
devtools::install_github('thomasp85/tidygraph')
```


```{r, error =TRUE}
library(tidygraph)

play_erdos_renyi(10, 0.5) %>% 
  activate(nodes) %>% 
  mutate(degree = centrality_degree()) %>% 
  activate(edges) %>% 
  mutate(centrality = centrality_edge_betweenness()) %>% 
  arrange(centrality)
```





```{r, error =TRUE}
glimpse(vehicle)
```

```{r}
vehicle %>% 
  count(Class) %>% 
  ggplot(mapping = aes(x = Class, y= n)) +
  geom_col() +
  geom_text(mapping = aes(label = n),
            color = 'red', size = 4, vjust = -0.5) +
  theme_bw()
```



```{r, error =TRUE}
library(ggraph)
#> Loading required package: ggplot2
library(tidygraph)

# Create graph of Popularity
graph <- as_tbl_graph(vehicle) %>% 
    mutate(Popularity = centrality_degree(mode = 'in'))

# plot using ggraph
ggraph(graph, layout = 'kk') + 
    geom_edge_fan(aes(alpha = after_stat(index)), show.legend = TRUE) + 
    geom_node_point(aes(size =Popularity, color = Popularity, alpha = 0.5)) + 
    facet_edges(~Class) + 
    theme_graph(foreground = 'steelblue', fg_text_colour = 'white')
```



```{r, error =TRUE}
vehicle %>% keep(is.factor) %>% summary()
```

In a vehicle dataset, the term "Comp" could refer to the vehicle's compression ratio. The compression ratio is a measurement of the engine's cylinder volume at its largest capacity (when the piston is at the bottom of the cylinder) compared to its smallest capacity (when the piston is at the top of the cylinder). It is usually represented as a decimal or a ratio.
The compression ratio is an important parameter in an internal combustion engine as it affects the engine's efficiency, power output, and fuel consumption. A higher compression ratio typically results in better engine performance but requires higher-octane fuel to prevent knocking or pinging.




# Which variable has the most missing values?
There is no missing values in the vehicle dataset

```{r, error =TRUE}
missing_counts <- sapply(vehicle, function(x) sum(is.na(x)))
print(missing_counts)
```
## Which variable has the most unique values?

Sc.Var.maxis with 424 number of unique values, has the most number of unique values

```{r}
unique_values <- sapply(vehicle, function(x) length(unique(x)))

# Display the number of unique values per column
print(unique_values)
```



```{r}
vehicle %>% 
  mutate(comp = cut(Comp,
                     breaks = seq(min(Comp), max(Comp), length.out = 31),
                     include.lowest = TRUE)) %>% 
  ggplot(mapping = aes(y = comp)) +
  geom_bar() +
  theme_bw()
```


```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Comp)) +
  geom_histogram(bins = 21,
                 mapping = aes(fill = '21')) +
  geom_histogram(bins = 31,
                 mapping = aes(fill = '31')) +
  ggthemes::scale_fill_calc('bins') +
  theme_bw()
```

```{r}
vehicle %>% 
  mutate(x_bin = cut(Comp,
                     breaks = seq(min(Comp), max(Comp), length.out = 51),
                     include.lowest = TRUE)) %>% 
  count(x_bin) %>% 
  mutate(rolling_sum = cumsum(n),
         rolling_prop = rolling_sum / sum(n) ) %>% 
  ggplot(mapping = aes(x = x_bin, y = rolling_prop)) +
  geom_bar(stat = 'identity') +
  theme_bw() +
  theme(axis.text.x = element_blank())
```

```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = value)) +
  geom_freqpoly(mapping = aes(color = Class, 
                              y = after_stat(density)),
                linewidth = 0.9,
                bins = 11) +
  facet_wrap(~name, scales = 'free') +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```

# Which of the input feature marginal distributions are roughly symmetric?
Kurt.Maxis, Skew.Maxis, Max.L.Ra, Pr.Axis.Ra, Max.L.Ra are roughly symmetric


```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = value)) +
  geom_histogram() +
  facet_wrap( ~ name, scales = 'free' ) +
  theme_bw()
```


# Do the input feature distribution shapes change across the categories of the output variable?
Yes, based on the ECDF (Empirical Cumulative Distribution Function) plots below, we can observe that the distributions of certain features vary across different categories. For example, the distribution of Holl.Ra and Kurt.Maxis, Ra.Gyr features differ among the different categories.

In the case of Holl.Ra, the distribution for the "opel" category appears to be roughly symmetric, while for the "bus" category, the distribution of Holl.Ra is not symmetric and shows a different shape.

Regarding the "Circ" feature, the distribution for the "bus" category exhibits a Gaussian behavior and is unimodal, whereas for the "saab" and "opel" categories, the distributions are multimodal, indicating multiple peaks or modes in the data.

These observations suggest that there are variations in the feature distributions across different categories of the output variable, indicating potential differences or relationships between the input features and the output variable.




```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = value)) +
  geom_density(mapping = aes(color = Class),
               linewidth = 0.5) +  
  facet_wrap( ~ name, scales = 'free' ) +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```


```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = value)) +
  stat_ecdf(mapping = aes(color = Class),
            linewidth = 0.5) +
  facet_wrap(~name, scales = 'free') +
  theme_bw()
```


# Do the input feature summary statistics change across the categories of the output variable?
Based on the box plots shown below, it is evident that the summary statistics of the input features vary across the categories of the output variable. The box plots provide insights into the changes in median, quartiles, and density of the input features for different categories of the output variable. These variations suggest that the input features have different distributions and characteristics based on the categories of the output variable.


```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = Class, y = value)) +
  geom_boxplot(mapping = aes(fill = Class,
                             color = Class),
               alpha = 0.3, linewidth = 1) +
  stat_summary(fun.data = 'mean_se',
               fun.args = list(mult = 0.1),
               color = 'red', size = 0.2) +
  facet_wrap(~name, scales = 'free_y') +
  theme_bw()
```

# Do the input feature averages vary across the categories of the output variable? Are there any inputs you are confident have different averages?

Yes, based on the analysis of the input feature averages across the categories of the output variable, it can be observed that there are inputs that have significantly different averages.

By comparing the average values of each input feature for different categories of the output variable, we can identify inputs that show distinct differences in their averages. These inputs are likely to have a significant impact on the output variable and may provide valuable insights or predictive power in distinguishing between the categories.

This is significantly observable in variables such as Kurt.Maxis

```{r}
vehicle %>% 
  tibble::rowid_to_column() %>% 
  pivot_longer(cols = !c("rowid", "Class")) %>% 
  ggplot(mapping = aes(x = Class, y = value)) +
  stat_summary(fun.data = 'mean_se',
               fun.args = list(mult = 2),
               color = 'red', size = 0.1) +
  facet_wrap(~name, scales = 'free_y') +
  theme_bw()
```

# Are the input features highly related to each other? Are the input features linearly related to each other?


```{r}
vehicle %>% 
  keep(is.numeric) %>% 
  bind_cols(vehicle %>% select(Class)) %>% 
  group_by(Class) %>% 
  group_modify( ~stretch( correlate(., diagonal = 1, quiet = TRUE) ) ) %>% 
  ungroup() %>% 
  ggplot(mapping = aes(x = x, y = y)) +
  geom_tile(mapping = aes(fill = r),
            color = 'white') +
  coord_equal() +
  facet_wrap(~Class) +
  scale_fill_gradient2(low = 'red', mid = 'grey', high = 'blue',
                       midpoint = 0,
                       limits = c(-1, 1)) +
  labs(x='', y='') +
  geom_text(aes(label = round(r, 2)), color = 'white', size = 4)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

```
Scat.Ra and Sc.Var.maxis have correlation coefficients of 1 in all 4 categories of vehicles, this means that they almost represent the same information and they are highly corelated and show linear relationship as it is illustrated below. Therefore I will be analyzing their relationships, as well as relationship between Kurt.maxis and Pr.Axis.Ra which have zero correlation in opel category for comparison of the plots. 


```{r}
vehicle %>% 
  ggplot( mapping = aes(x = Sc.Var.maxis, y = Scat.Ra))+
          geom_hex(bins= 10,
                              mapping = aes(fill = after_stat(ncount)))+
          facet_wrap(~Class)+
          scale_fill_viridis_c()+
          theme_bw()
```





```{r}
vehicle %>% 
  ggplot( mapping = aes(x = Sc.Var.maxis, y = Scat.Ra))+
          geom_hex(bins= 10,
                              mapping = aes(fill = after_stat(ncount)))+
          facet_wrap(~Class)+
          scale_fill_viridis_c()+
          scale_y_log10()+
          scale_x_log10()+
          theme_bw()
```



```{r}
vehicle %>% 
  ggplot( mapping = aes(x = Sc.Var.maxis, y = Scat.Ra))+
  geom_point(size = 2.5,
             mapping = aes(color = Class)) +
  geom_smooth(mapping = aes(color = Class,
                            fill = Class),
              method = lm,
              formula = y ~ x) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_bw()
```










```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Kurt.maxis, y = Pr.Axis.Ra)) +
          geom_hex(bins= 10,
                              mapping = aes(fill = after_stat(ncount)))+
          facet_wrap(~Class)+
          scale_fill_viridis_c()+
          theme_bw()
```







```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Kurt.maxis, y = Pr.Axis.Ra)) +
          geom_hex(bins= 10,
                              mapping = aes(fill = after_stat(ncount)))+
          facet_wrap(~Class)+
          scale_fill_viridis_c()+
          scale_y_log10()+
          scale_x_log10()+
          theme_bw()
```





```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Kurt.maxis, y = Pr.Axis.Ra)) +
  geom_point(size = 2.5,
             mapping = aes(color = Class)) +
  geom_smooth(mapping = aes(color = Class,
                            fill = Class),
              method = lm,
              formula = y ~ x) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_bw()
```
It is evident that the relationship between Kurt.maxis, y = Pr.Axis.Ra is not linear versus the relationship between Sc.Var.maxis and Scat.Ra that are highly linear.





The variable "Scat.Ra" in a vehicle dataset could refer to the scatter rating or scatter resistance rating. Scatter rating is a measure of how well a vehicle resists scattering or dispersion of light. It is often used to evaluate the quality of the vehicle's paint or finish.
A higher scatter rating indicates better scatter resistance, meaning that the vehicle's paint or finish is less prone to scattering light and provides a more uniform appearance. On the other hand, a lower scatter rating suggests that the vehicle's paint or finish may scatter light more, resulting in a less uniform or glossy appearance.




```{r}
summary(vehicle[1])
```

```{r}
summary(vehicle[2])
```

```{r}
attributes(vehicle$Class)
```




```{r}
vehicle %>% count(Class)
```

```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Class)) +
  geom_bar() +
  geom_text(stat = 'count',
          mapping = aes(label = after_stat( count )),
          color = 'red', nudge_y = 10, size = 5.5) +
  theme_bw()
```



  



Circ         
D.Circ       
Rad.Ra       
Pr.Axis.Ra   
Max.L.Ra     
Scat.Ra  
Elong        
Pr.Axis.Rect 
Max.L.Rect   
Sc.Var.Maxis 
Sc.Var.maxis 
Ra.Gyr       
Skew.Maxis   
Skew.maxis   
Kurt.maxis   
Kurt.Maxis   
Holl.Ra      
Class  


# Do the relationships between the input features change across the categories of the output variable?
Yes, in order to make sure this is true lets take a look at the relationship between `Holl.Ra` and `Sc.Var.maxis`

```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Holl.Ra, y = Sc.Var.maxis)) +
  geom_point(size = 2.5,
             mapping = aes(color = Class)) +
  geom_smooth(mapping = aes(color = Class,
                            fill = Class),
              method = lm,
              formula = y ~ x) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_bw()
```
As it is evident from the plot above, relationship between `Holl.Ra` and `Sc.Var.maxis` varies between categories. For example the relationship is almost linear in van category but it is not linear in the bus category.




From the plots, it is evident that Holl.Ra and Kurt.Maxis, Skew.Maxis, Max.L.Ra, Pr.Axis.Ra, Rad.Ra exhibit a linear relationship, whereas Holl.Ra and Kurt.maxis, Skew.maxis, Ra.Gyr, Sc.Var.maxis, Sc.Var.Maxis, Max.L.React, Pr.Axis.Rect, Elong, Scat.Ra, D.Circ, Circ, Comp, do not follow a linear pattern.

From the plots, it is evident that Holl.Ra and Kurt.Maxis, Skew.Maxis, Max.L.Ra, Pr.Axis.Ra, Rad.Ra exhibit a linear relationship, whereas Holl.Ra and Kurt.maxis, Skew.maxis, Ra.Gyr, Sc.Var.maxis, Sc.Var.Maxis, Max.L.React, Pr.Axis.Rect, Elong, Scat.Ra, D.Circ, Circ, Comp, do not follow a linear pattern.





# Are there clusters of observations between pairs of input features? If so, do the clusters correspond to categories of the output variable?



```{r}
vehicle %>% 
  ggplot(mapping = aes(x = Ra.Gyr, y = Sc.Var.Maxis)) +
  geom_point(size = 2.5,
             mapping = aes(color = Class)) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_bw()
```

Yes, there are distinct clusters of observations that correspond to the categories of the output variable. For instance, consider the scatter plot depicting the relationship between Ra.Gyr and Sc.Var.Maxis. In this plot, it is evident that the van category is primarily concentrated in the lower values of both variables. On the other hand, the bus category exhibits a broader distribution with higher values compared to the van category. The opel and saab categories are positioned in the middle part of the plot. These observations suggest that there are clear associations between the input features and the categories of the output variable, indicating potential relationships and patterns in the data.
















