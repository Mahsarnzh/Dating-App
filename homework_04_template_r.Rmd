---
title: "CMPINF 2130 Summer 2023 - Homework 04"
subtitle: "Assigned June 8, 2023; Due June 15, 2023"
author: "Your Name Here"
date: 'Submission time: June 15, 2023 11:00PM EST'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Collaborators

Include the names of other students you worked with here.  

## Overview

You will work with 3 data sets in this assignment. Two of the data sets will be explored in both R and Python. This allows you to directly compare figures between the two languages. As with the previous assignment, two of the data sets are new. The third data set is the EPA AQI data. You will therefore continue exploring this complicated data set.  

This assignment is focused entirely on exploring the relationships between categorical and continuous variables. Specifically, you are examining the **conditional distributions** of a continuous variable **given** a categorical variable. You will need the skills and concepts presented in lecture and the readings to complete this assignment.  

The three data sets for this assignment are:  

* Synthetic data created for this assignment to practice visualizing the impact of sample size  
  * The data involve a single continuous variable and a single categorical variable  
  * Problem 01 uses this data set  
* A real **binary classification** data set  
  * The data consists of two continuous *inputs* and one categorical *output*  
  * The categorical output is binary and thus has two values  
  * This is a real data set and comes from a popular binary classification problem in machine learning  
  * You are working with just two of the inputs even though the full problem has many more  
  * Problems 02 and 03 are associated with this data set
* The EPA Air Quality System (AQS) data from homework 02  
  * You will explore the conditional distribution of `daily_avg` given the Month
  * You will therefore use conditional distributions to explore behavior over time  
  * Problem 04 is associated with the EPA AQS data  
  
You will explore the synthetic data and binary classification data in both R and Python. The EPA AQS data will only be explored in R.  

The last problem, Problem 05, requires you to read in potential data for your final project. You may answer this problem in either Python or R.  


**Important**: Please download all CSV files from the Canvas site and save them in the same directory as your RMarkdown file. The code chunks read in the CSV files assuming they are in the same directory.  

## Problem 00

**Load or import the `tidyverse` in the code chunk below.**  

#### SOLUTION

```{r, load_tidyverse}
library(tidyverse)
```

## Problem 01

The synthetic data are read in for you in the code chunk below and assigned to the `df` object. There is 1 continuous variable and 1 categorical variable in the data set. The continuous variable is named `x` and the categorical variable is named `m`.  

```{r, read_synthetic}
df <- readr::read_csv('hw04_synthetic.csv', col_names = TRUE)
```

### 1a)

**Create a bar chart to show the counts associated with the categorical variable `m`.**  

**Are the categories balanced?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = m)) +
  geom_bar(mapping = aes(x = m)) +
  theme_bw()
```

What do you think?  
```{r}
df %>% 
  count(m) %>% 
  ggplot(mapping = aes(x = m, y = n)) +
  geom_col() +
  geom_text(mapping = aes(label = n),
            color ='red', size = 5.5, nudge_y = 200) +
  theme_bw()
```


### 1b)

**Create a histogram to show the MARGINAL distribution of the continuous variable `x`. Use an appropriate number of bins based on the sample size.**  

**How would you describe the shape of the MARGINAL distribution?**  

#### SOLUTION

```{r}
df %>% glimpse()
```

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  geom_histogram(bins = 20) +
  theme_bw()
```

What do you think?  

### 1c)

Let's try to explore the conditional distribution by using the default conditional histogram in `ggplot2`.  

**Create a conditional histogram to visualize the CONDITIONAL distribution of the continuous variable `x` GIVEN the categorical variable `m`. Map the categorical variable `m` to the `fill` aesthetic. You must use a COUNT histogram. Use an appropriate number of bins based on the sample size.**  

**Use a color blind friendly fill scale.**  

**Are the conditional distributions different across the categories of `m`?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  geom_histogram(mapping = aes(fill = m),
                 bins = 21) +
  ggthemes::scale_fill_colorblind() +
  theme_bw()
```

What do you think?  

### 1d)

Let's now move away from the FILLED count histogram. You will represent the histogram as a FREQUENCY POLYGON. However, you will NOT modify the y-aesthetic for the frequency polygon in this problem.  

**Create a conditional FREQUENCY POLYGON to visualize the CONDITIONAL distribution of the continuous variable `x` GIVEN the categorical variable `m`. Map the categorical variable `m` to the `color` aesthetic. You must use a COUNT frequency polygon. Change the `linewidth` so the lines are easy to see. Use the same number of bins as you used in 1c).**  

**Use a color blind friendly color scale.**  

**Are the conditional distributions different across the categories of `m`?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  geom_freqpoly(bins = 23, mapping = aes(color = m),
                 linewidth = 1.) +
    ggthemes::scale_color_colorblind() +

  theme_bw()
```

What do you think?  

### 1e)

Let's now create another FREQUENCY POLYGON but this time the `y`-aesthetic must show the **density** instead of the **count**!  

**Create a conditional FREQUENCY POLYGON to visualize the CONDITIONAL distribution of the continuous variable `x` GIVEN the categorical variable `m`. Map the categorical variable `m` to the `color` aesthetic. You must modify the `y` aesthetic such that the DENSITY is calculated by the STATISTICAL TRANSFORMATION instead of the COUNT. Change the `linewidth` so the lines are easy to see. Use the same number of bins as you used in 1c).**  

**Use a color blind friendly color scale.**  

**Are the conditional distributions different across the categories of `m`?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  geom_freqpoly(bins = 11,
                mapping = aes(color = m,
                              y = after_stat(density)),
                linewidth = 1.2) +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```

What do you think?  

### 1f)

The density can be estimated and visualized through another approach. The density can be estimated and represented by a smooth curve via a Kernel Density Estimate (KDE). You used KDE plots in the previous assignment to study marginal distributions. You will now use a CONDITIONAL KDE to visualize conditional distributions.  

**Create a conditional KDE plot to visualize the CONDITIONAL distribution of the continuous variable `x` GIVEN the categorical variable `m`. Map the categorical variable `m` to the `color` aesthetic. Change the `linewidth` so the lines are easy to see. You may use the default bandwidth.**  

**Use a color blind friendly color scale.**  

**Are the conditional distributions different across the categories of `m`?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  stat_ecdf(mapping = aes(color = m),
            linewidth = 1.0) +
  geom_hline(yintercept = 0.5,
             color = 'red', linetype = 'dashed', linewidth = 0.5) +
  ggthemes::scale_color_colorblind() +
  theme_bw()

```

What do you think?  

### 1g)

Lastly, distributions can be represented via empirical Cumulative Distribution Function (eCDF) plots. The eCDF represents the distributional shape and supports visualizing Quantiles because the eCDF calculates the cumulative proportion. You will now use CONDITIONAL eCDF to visualize conditional distributions.  

**Create a conditional eCDF plot to visualize the CONDITIONAL distribution of the continuous variable `x` GIVEN the categorical variable `m`. Map the categorical variable `m` to the `color` aesthetic. Change the `linewidth` so the lines are easy to see.**  

**Use a color blind friendly color scale.**  

**Are the conditional distributions different across the categories of `m`?**  

#### SOLUTION

Add your code chunks here.  
```{r}
df %>% 
  ggplot(mapping = aes(x = x)) +
  stat_ecdf(mapping = aes(color = m),
            linewidth = 1.2) +
  geom_hline(yintercept = 0.5,
             color = 'red', linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```

What do you think?  

### 1h)

Let's wrap up this problem by reviewing the relationship between the various plots you created to study the CONDITIONAL distribution.  

**Did your opinions about the differences between the conditional distributions change when you forced the FREQUENCY polygon to use DENSITY instead of COUNT? If so why? Were your conclusions consistent between the conditional FREQUENCY polygon, KDE, and eCDF plots?**  

**Which type of plot did you feel was easiest to interpret?**  

#### SOLUTION

What do you think? ????????????? 

## Problem 02

The small binary classification data is read in for you in the code chunk below and assigned to the `df_class` object. The data consists of three variables. The first two, `A` and `B`, correspond to input features and the third variable `Class` is a binary outcome of interest. The data comes from a data set that is commonly used to teach binary classification models in machine learning. You are working with a small fraction of the inputs to the problem. The variable names have been changed to try and hide just which data set this is in case you have seen this problem before!  

```{r, read_binary}
df_class <- readr::read_csv('hw04_small_classification.csv')
```

### 2a)

**Create a bar chart to show the counts of the categorical variable.**  

**Are the categories balanced?**  

#### SOLUTION
```{r}
df_class %>% glimpse()
```
```{r}
df_class %>% 
  count(Class) %>% 
  ggplot(mapping = aes(x = Class, y =n)) +
  geom_col(mapping = aes(x = Class)) +
  geom_text(mapping = aes(label = n),
            color ='red', size = 5.5, nudge_y = 10) +
  theme_bw()
```
They are not Balanced.

### 2b)

**Create histograms to visualize the MARGINAL distributions of the continuous variables. Use an appropriate number of bins based on the sample size.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  geom_histogram(bins = 10) +
  theme_bw()
```


```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  geom_histogram(bins = 10) +
  theme_bw()
```

Add your code chunks here.  

### 2c)

Now that you have studied the MARGINAL histograms, it is time to consider the CONDITIONAL histograms! You will NOT use the DEFAULT histogram settings in this problem. You MUST create your conditional FREQUENCY polygons such that the `y` aesthetic displays the DENSITY and NOT the count.  

**Create conditional FREQUENCY polygons to visualize the CONDITIONAL distributions of the continuous variables GIVEN the categorical variable. Map the categorical variable to the appropriate aesthetic. Make the corresponding modification such that the DENSITY is displayed rather than the COUNT. Use an appropriate number of bins based on the sample size.**  

**Use the `ggthemes::scale_color_calc()` color scale instead of the color blind friendly scale.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION

Add your code chunks here.  
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  geom_freqpoly(bins = 11,
                mapping = aes(color = Class,
                              y = after_stat(density)),
                linewidth = 1.2) +
  ggthemes::scale_color_colorblind() + 
  theme_bw()
```

```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  geom_freqpoly(bins = 11,
                mapping = aes(color = Class,
                              y = after_stat(density)),
                linewidth = 1.2) +
  ggthemes::scale_color_colorblind() + 
  theme_bw()
```

### 2d)

In lecture, we learned that it can be useful to show the MARGINAL and CONDITIONAL distributions on the same graphic. You are therefore able to compare the continuous distribution across categories AND to the distribution which ignores all other variables.  

**Create graphics which include the MARGINAL and CONDITIONAL distribution of the continuous variables GIVEN the categorical variable. You must represent the MARGINAL and CONDITIONAL distributions via FREQUENCY polygons. Make the corresponding modification such that the DENSITY is displayed rather than the COUNT. Use an appropriate number of bins based on the sample size.**  

**Use the `ggthemes::scale_color_calc()` color scale instead of the color blind friendly scale for the CONDITIONAL distributions. Hard code the MARGINAL distribution to be a color of `'grey50'`.**  

*HINT*: You may use separate code chunks for each variable.  


```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  geom_freqpoly(data = df_class %>% select(A),
                bins = 17,
                mapping = aes(y = after_stat(density)),
                color = 'grey', linewidth = 1.55) +
  geom_freqpoly(mapping = aes(y = after_stat(density)),
                color = 'blue',
                bins = 11) +
  facet_wrap(~Class) +
  ggthemes::scale_color_calc() +
  theme_bw()
```
```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  geom_freqpoly(data = df_class %>% select(B),
                bins = 17,
                mapping = aes(y = after_stat(density)),
                color = 'grey', linewidth = 1.55) +
  geom_freqpoly(mapping = aes(y = after_stat(density)),
                color = 'blue',
                bins = 11) +
  facet_wrap(~Class) +
  ggthemes::scale_color_calc() +
  theme_bw()
```

### 2e)

Let's now consider the eCDF to represent the MARGINAL distributions of the continuous variables.  

**Create eCDFs to visualize the MARGINAL distributions of the continuous variables.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  stat_ecdf(linewidth = 1.75, color = 'purple') +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```

Add your code chunks here.  
```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  stat_ecdf(linewidth = 1.75, color = 'purple') +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_colorblind() +
  theme_bw()
```

### 2f)

Let's now consider the how the eCDF changes across categories by visualizing the CONDITIONAL eCDF!  

**Create conditional eCDFs to visualize the CONDITIONAL distributions of the continuous variables GIVEN the categorical variable. Map the categorical variable to the appropriate aesthetic.**  

**Use the `ggthemes::scale_color_calc()` color scale instead of the color blind friendly scale.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  stat_ecdf(linewidth = 1.2,
            mapping = aes(color = Class)) +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_calc()+
  theme_bw()
```

Add your code chunks here.  
```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  stat_ecdf(linewidth = 1.2,
            mapping = aes(color = Class)) +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_calc()+
  theme_bw()
```



### 2g)

Lastly, let's include the MARGINAL eCDF and the CONDITIONAL eCDFs on the same graphic.  

**Create graphics which include the MARGINAL eCDF and CONDITIONAL eCDFs of the continuous variables GIVEN the categorical variable.**  

**Use the `ggthemes::scale_color_calc()` color scale instead of the color blind friendly scale for the CONDITIONAL distributions. Hard code the MARGINAL distribution to be a color of `'grey50'`.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A)) +
  stat_ecdf(linewidth = 1.75, color = 'green') +
  stat_ecdf(linewidth = 1.2,
            mapping = aes(color = Class)) +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_calc()+
  theme_bw()
```
Add your code chunks here.  
```{r}
df_class %>% 
  ggplot(mapping = aes(x = B)) +
  stat_ecdf(linewidth = 1.75, color = 'yellow') +
  stat_ecdf(linewidth = 1.2,
            mapping = aes(color = Class)) +
  geom_hline(yintercept = 0.5, color = 'red',
             linetype = 'dashed', linewidth = 1.2) +
  ggthemes::scale_color_calc()+
  theme_bw()
```

### 2h)

You have explored the categorical-to-continuous relationship through multiple approaches of visualizing the CONDITIONAL distribution.  

**Is the binary response, `Class`, associated with different distributions of the continuous inputs? Which type of plot did you feel was easier to use to reach your conclusion?**  

#### SOLUTION

What do you think?  ???????????????????

## Problem 03

You will continue to use the `df_class` data set for this problem. In lecture we discussed that there are multiple types of *specialized* graphics to study categorical-to-continuous relationships. The specialized graphics focus on particular aspects of the conditional histogram and conditional eCDF plots. Thus, these specialized graphics have various pros and cons. Let's get practice working those specalized graphics now.  

### 3a)

You will start by using boxplots to compare the summary stats of the conditional distributions given the categorical variable.  

**Create boxplots for the continuous variables given the categorical variable. You should use separate graphics for each continuous variable.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  ggplot(mapping = aes(x = A, y = Class)) +
  geom_boxplot()
```
```{r}
df_class %>% 
  ggplot(mapping = aes(x = B, y = Class)) +
  geom_boxplot()
```

Add your code chunks here.  

### 3b)

The boxplot does NOT include the conditional MEAN (average) by default. You will include the conditional MEAN on top of the boxplot to help provide further information about the distributions.  

**Create boxplots for the continuous variables given the categorical variable. The conditional mean should be included as a RED point on top of the boxes. Create the conditional means via the `stat_summary()` function. You must specify the `geom` argument to `stat_summary()` such that the mean is shown as a POINT. You should use separate graphics for each continuous variable.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION
```{r}
df_class %>% 
  mutate(Class = fct_reorder(Class, A, .fun = 'mean')) %>% 
  ggplot(mapping = aes(y = Class, x = A)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun = 'mean', geom = 'point',
               color = 'red', size = 2.5) +
  theme_bw()
```


```{r}
df_class %>% 
  mutate(Class = fct_reorder(Class, B, .fun = 'mean')) %>% 
  ggplot(mapping = aes(y = Class, x = B)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun = 'mean', geom = 'point',
               color = 'red', size = 2.5) +
  theme_bw()
```

Add your code chunks here.  

### 3c)

Sometimes we are particularly interested in comparing AVERAGES across categories. For example, we might be interested in knowing if the average is DIFFERENT across the categories. However, we cannot make such a conclusion by simply comparing the mean values. We must also consider the uncertainty of the estimate. We need to know how *confident* we are. Thus, we need to include the 95% confidence interval on the conditional means. You will compare the averages of the continuous variables across the categories of the categorical variable in this problem.  

**Create a plot which shows the conditional means of the continuous variables given the categorical variable. You must set the arguments of `stat_summary()` to correctly include the 95% confidence interval on the conditional means. Increase the `linewidth` and the marker `size` such that the markers and error bars are easy to see. You should use separate graphics for each continuous variable.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION

```{r}
df_class %>% 
  mutate(Class = fct_reorder(Class, A, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = Class, x = A)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 2),
               color = 'red', linewidth = 1.2, size = 0.5) +
  theme_bw()
```


```{r}
library(ggplot2)
library(dplyr)
library(forcats)

df_class %>%
  mutate(Class = fct_reorder(Class, A, .fun = 'median')) %>%
  ggplot(mapping = aes(y = Class, x = A)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun = 'mean', geom = 'point', color = 'red', size = 2.5) +
  stat_summary(fun.data = mean_cl_normal, geom = 'errorbar', width = 0.2) +
  theme_bw()
```   


```{r}
df_class %>% 
  mutate(Class = fct_reorder(Class, B, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = Class, x = B)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 2),
               color = 'red', linewidth = 1.2, size = 0.5) +
  theme_bw()
```

```{r}
df_class %>%
  mutate(Class = fct_reorder(Class, B, .fun = 'median')) %>%
  ggplot(mapping = aes(y = Class, x = B)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun = 'mean', geom = 'point', color = 'red', size = 2.5) +
  stat_summary(fun.data = mean_cl_normal, geom = 'errorbar', width = 0.2) +
  theme_bw()
```

Add your code chunks here.  

### 3d)

Comparing summary statistics across categories is useful and important. However, that is not the complete picture. We also need to consider the changes in the distributional shape. You studied the shapes extensively in Problem 2, but there are specialized graphics that focus on the conditional distributional shapes as well. You will explore how the distributional shapes change in this problem via the VIOLIN plot.  

**Create Violin plots for the continuous variables given the categorical variable. You should use separate graphics for each continuous variable.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION

```{r}
df_class %>% 
  ggplot(mapping = aes(y = Class, x = A)) +
  geom_violin(fill = 'grey') +
  theme_bw()
```

Add your code chunks here.  

```{r}
df_class %>% 
  ggplot(mapping = aes(y = Class, x = B)) +
  geom_violin(fill = 'grey') +
  theme_bw()
```

### 3e)

The violin plot and boxplot can be combined into a composite graphic. This figure will therefore show the distributional shapes and summary stats given the categories. Such figures can be supplemented further by including the raw data as strip plots. The markers help give an idea about the *quality* of the density estimate represented by the violin.  

**Create composite graphics which include Violin plots, boxplots, and strip plots for the continuous variables given the categorical variable. Hard code the violin and boxplot `fill` aesthetics accordingly. Specify the jittering of the points in the strip plot such that the markers are clearly associated with each categorical group. You should use separate graphics for each continuous variable.**  

*HINT*: You may use separate code chunks for each variable.  

#### SOLUTION

```{r}
df_class %>% 
  ggplot(mapping = aes(x = Class, y = A)) +
  geom_jitter(width = 0.2, height = 0) +
  geom_violin(fill = 'pink', alpha = 0.2) +
  geom_boxplot(fill = NA, outlier.shape = NA, 
               linewidth = 1.2) +
  theme_bw()
```


```{r}
df_class %>% 
  ggplot(mapping = aes(x = Class, y = B)) +
  geom_jitter(width = 0.2, height = 0) +
  geom_violin(fill = 'purple', alpha = 0.2) +
  geom_boxplot(fill = NA, outlier.shape = NA, 
               linewidth = 1.2) +
  theme_bw()
```
 

### 3f)

You have explored the categorical-to-continuous relationship through specialized multiple approaches.  

**Is the binary response, `Class`, associated with different distributions of the continuous inputs? Which type of specialized plot did you feel was easier to use to reach your conclusion? Were the specalized plots easier to work with than the various conditional distribution plots you made in Problem 2? What do you think?**  

#### SOLUTION

What do you think?  ??????????????????????????

## Problem 04

You began exploring the `daily_avg` variable of the EPA AQI data in the previous assignment. You considered the marginal distribution and then explored the conditional distribution given the `city` and `county`. You will work with the `daily_avg` variable again but this time focus on the conditional distribution given Months!  

The code chunk below reads in the EPA AQS data and assigns the data to the `epa` variable. The code chunk ASSUMES the EPA AQS data are contained within the `'hw/02'` sub-directory. The file path includes `'../02'` which represents moving *backwards* and then *entering* the `'02'` subdirectory. Thus, the code chunk below assumes this RMarkdown is within the `'hw/04'` subdirectory. The code chunk below is different from the previous assignments. Date time components are attracted from the `date` column using functions from the `lubridate` package. We have not discussed dates in CMPINF 2130 yet. That is why the `Year`, `Month`, and `Day` variables are extracted for you. The `lubridate` package is part of `tidyverse` and thus it was installed when you installed `tidyverse`. You do NOT need to install it again.  

**IMPORTANT**: The `eval` flag is set to `FALSE` in the code chunk below. You MUST change it so `eval=TRUE` in order to Knit the document.  

```{r, read_epa, eval=FALSE}
epa <- readr::read_csv('../Week_02/epa_airdata_small.csv', col_names = TRUE) %>% 
  mutate(Year = lubridate::year(date), 
         Month = lubridate::month(date, label = TRUE, abbr = TRUE),
         Day = lubridate::day(date))
```

The code chunk below provides the `glimpse()` of the `epa` data. The glimpse shows that the `Year`, `Month`, and `Day` columns are available in `epa`.  

```{r, glimpse_epa, eval=FALSE}
epa %>% glimpse()
```

### 4a)

**Use the `count()` function to count the number of rows associated with each unique value of `Year`.**  

**How many unique years are present in the data?**  

#### SOLUTION

4 unique years are present in the data

```{r}
epa %>% count(Year)
```


```{r}
epa %>% 
  group_by(Year) %>% 
  summarise(num_rows = n(),
            .groups = 'drop')
```

Add your code chunks here.  

### 4b)

**Use the `count()` function to count the number of rows associated with each unique value of `Month`.**  

**How many unique months are present in the data?**  12 unique months are present in the data

#### SOLUTION

```{r}
epa %>% 
  group_by(Month) %>% 
  summarise(num_rows = n(),
            .groups = 'drop')
```
### 4c)

You should have seen in the previous assignment that `epa` contains measurements for 4 different pollutants. You visualized the distributions of all 4 pollutants in the previous assignment. However, let's simplify things in this assignment by focusing our attention on just one of those pollutants. You will focus on Carbon Monoxide for the remainder of the problem.  

**Filter the `epa` data to all rows associated with Carbon Monoxide. Assign the filtered data to the `co` object.**  

*HINT*: Use the `count()` function on the `pollutant` column to check the spelling of Carbon Monoxide in the `epa` data set!  

#### SOLUTION

```{r}
epa %>%
  count(pollutant)
```

```{r}
co <- filter(epa, pollutant == "Carbon monoxide")
head(co)
```

```{r}
co <- filter(epa, pollutant == "Carbon monoxide")
tail(co)
```

or: 

```{r}
epa %>% 
  rowid_to_column() %>% 
  filter( pollutant == 'Carbon monoxide' ) %>% 
  head()
```



### 4d)

Let's now study the behavior of the Carbon Monoxide `daily_avg` over time!  

**Create a boxplot to summarize the distribution of `daily_avg` within the `co` data set given the `Month`.**  

#### SOLUTION

```{r}
co %>% 
  mutate(Month = fct_reorder(Month, daily_avg, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = Month, x = daily_avg)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 2),
               color = 'red', linewidth = 1.2, size = 0.88) +
  theme_bw()
```

Add your code chunks here.  

### 4e)

Your explorations of `epa` in the previous assignments revealed that there are multiple sites the measurements were collected at. The previous boxplot in 4d) did NOT consider the `site` grouping! Let's now include such a grouping via facets! You are therefore creating a boxplot to study the conditional distribution of `daily_avg` given the combination of TWO categorical variables!  

**Create a boxplot to summarize the distribution of `daily_avg` within the `co` data set given the `Month`. Create facets via the `facet_wrap()` function where the facets are associated with `site`.**  

#### SOLUTION
```{r}
co %>% 
  mutate(Month = fct_reorder(Month, daily_avg, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = Month, x = daily_avg)) +
  geom_boxplot(fill = 'pink') +
  facet_wrap( ~site, scales = 'free_y' ) +

  theme_bw()
```

Add your code chunks here.  

### 4f)

So far, we have only used the `facet_wrap()` function to manage facets or subplots. As the name states, the facets are "wrapped" around the graphical device (window). However, there is another way to manage facets. We can arrange facets in a GRID. The GRID allows associated a variable with ROW (vertical) and COLUMN (horizontal) facets. Thus, the facets can be associated with 2 separate variables. The INTERSECTION within the GRID arrangement represents a COMBINATION of those two variables.  

Grid facets are managed by the `facet_grid()` function. The syntax is demonstrated below:  

`facet_grid( <row variable> ~ <column variable> )`  

The `<row variable>` is a place holder for the variable you wish to associate with the ROW or VERTICAL facets. The `<column variable>` is the place holder for the variable you wish to associate with the COLUMN or HORIZONTAL facets. The formula interface represents reads as if the "vertical facets are a function of the horizontal facets".  

You will use grid facets to include `Year` and `site` as grouping variables in your boxplots. Thus, you are creating conditional distributions GIVEN three variables!  

**Create a boxplot to summarize the distribution of `daily_avg` within the `co` data set given the `Month`. Create facets via the `facet_grid()` function where the row facets are associated with `Year` and the column facets are associated with `site`.**  

#### SOLUTION

```{r}
co %>% 
  mutate(Month = fct_reorder(Month, daily_avg, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = Month, x = daily_avg)) +
  geom_boxplot(fill = 'pink') +
  facet_grid(Year ~site, scales = 'free_y' ) +

  theme_bw()
```

### 4g)

Let's now consider if the Monthly average `daily_avg` value is DIFFERENT across the months.  

**Create a plot to show the conditional means of `daily_avg` within the `co` data set given the `Month`. You must set the arguments of `stat_summary()` to correctly include the 95% confidence interval on the conditional means. Set the `linewidth` and the marker `size` such that the markers and error bars are easy to see. Create facets via the `facet_grid()` function where the row facets are associated with `Year` and the column facets are associated with `site`.**  

#### SOLUTION

Add your code chunks here.  
```{r}
co %>% 
  mutate(Month = fct_reorder(Month, daily_avg, .fun = 'mean')) %>% 
  ggplot(mapping = aes(y = Month, x = daily_avg)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 2),
               color = 'red', linewidth = 1.2, size = 0.2) +
  facet_grid(Year ~site, scales = 'free_y' ) +

  theme_bw()
```

### 4h)

You might see a warning message displayed in the previous figure. Let's use a heat map to help figure out what's going on!  

**Create a heat map that shows the counts of the number of observations for each combination of `Year`, `Month`, and `site` within the `co` data set. The heat map `fill` must be associated with the count using a sequential color scale. The count must also be annotated via text and the text color must depend on the count.**  

**Why do you think the warning message was displayed in 4g), based on your heat map?**  

#### SOLUTION

```{r}
co %>% 
  count(Year, Month, site) %>% 
  ggplot(mapping = aes(x = Year, y = Month)) +
  geom_tile(mapping = aes(fill = n),
            color = 'black') +
  geom_text(mapping = aes(label = n,
                        color = n > mean(n))) +
  facet_grid(~site, labeller = 'label_both') +

  scale_fill_viridis_c() +
  theme_bw()
```

### 4i)

We have focused a lot on changes in summary stats in this problem. But, we cannot forget about examining the distributional shapes as well!  

**Create a Violin plot to represent the conditional distribution of `daily_avg` within the `co` data set given the `Month`. Create facets via the `facet_grid()` function where the row facets are associated with `Year` and the column facets are associated with `site`.**  

**Do the conditional distributions roughly look like Bell curves?**  

#### SOLUTION

```{r}
co %>% 
  ggplot(mapping = aes(x = daily_avg, y = Month)) +
  geom_jitter(width = 0.2, height = 0) +
  geom_violin(fill = 'purple', alpha = 0.2) +
  geom_boxplot(fill = NA, outlier.shape = NA, 
               linewidth = 0.2) +
    facet_grid(Year ~site, labeller = 'label_both') +

  theme_bw()
```

## Problem 05

Last assignment you explored counts and marginal distributions of variables in data of your choosing. You will expand on your previous work by exploring CONDITIONAL distributions!  

**You must identify 1 continuous and 1 categorical variable in your data. You must explore the categorical-to-continuous relationship using ALL relevant plots from this assignment. Specifically you MUST use:**  



* Conditional density plots  ????? KDE 

**You MUST contact Dr. Yurko if your data ONLY contains continuous variables OR ONLY contains categorical variables.**  

#### SOLUTION: Conditional frequency polygons, appropriately modified  

```{r}
library(tidytuesdayR)
```

Add your code chunks here.  
```{r}
big_tech_stock_prices <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-02-07/big_tech_stock_prices.csv')
```
```{r}
library(ggplot2)
library(readr)
library(dplyr)
```

```{r}
big_tech_stock_prices %>% glimpse()

```

```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = open)) +
  geom_freqpoly(bins = 11,
                mapping = aes(color = stock_symbol,
                              y = after_stat(density)),
                linewidth = 1.2) +
  theme_bw()
```

```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = open)) +
  geom_density(color = 'pink', linewidth = 1.55) +
  geom_density(mapping = aes(color = stock_symbol),
               linewidth = 1.) +
  theme_bw()
```



### * Conditional eCDF plots  

```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = open)) +
  stat_ecdf(mapping = aes(color = stock_symbol),
            linewidth = 1.2) +
  geom_hline(yintercept = 0.5,
             color = 'red', linetype = 'dashed', linewidth = 1.2) +
  theme_bw()
```



```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = high)) +
  stat_ecdf(mapping = aes(color = stock_symbol),
            linewidth = 1.2) +
  geom_hline(yintercept = 0.5,
             color = 'red', linetype = 'dashed', linewidth = 1.2) +
  theme_bw()
```
* Boxplots

```{r}
big_tech_stock_prices %>% 
  mutate(stock_symbol = fct_reorder(stock_symbol, open, .fun = 'median')) %>% 
  ggplot(mapping = aes(y = stock_symbol, x = open)) +
  geom_boxplot(fill = 'grey') +
  stat_summary(fun.data = 'mean_se', 
               fun.args = list(mult = 0.1),
               color = 'red', linewidth = 1.2, size = 0.1) +
  theme_bw()
```

* Violin plots  


```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = stock_symbol, y = open)) +
  geom_violin(fill = 'pink') +
  theme_bw()
```

```{r}
big_tech_stock_prices %>% 
  ggplot(mapping = aes(x = stock_symbol, y = open)) +
  geom_jitter(width = 0.2, height = 0.01) +
  geom_violin(fill = 'red', alpha = 0.2) +
  geom_boxplot(fill = 'yellow', outlier.shape = NA, 
               linewidth = 0.2) +
  theme_bw()
```






